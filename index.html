<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Drone Swarm Radar — Ops Console</title>
  <style>
    :root{
      /* Palette */
      --bg:#070b12;
      --ink:#ffffff;
      --hud:#9de1ff;
      --locked:#ff5b5b;
      --defender:#31c9ff;
      --accent:#00ffd5;
      --dim:#6c8793;
      --grid:#343434;

      /* Beam tuning (body tint; NVG bloom set in JS) */
      --beam-core: rgba(255, 255, 255, 0.10);
      --beam-fill: rgba(255, 255, 255, 0.15);
    }

    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--ink);
      font:14px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      overflow:hidden;
    }
    canvas{
      display:block; width:100vw; height:100vh; background:var(--bg);
      touch-action:none;
    }
    .hud{
      position:fixed; z-index:2; color:var(--hud); letter-spacing:.08em; text-transform:uppercase;
      font-size:12px; opacity:.95; user-select:none; pointer-events:none;
      mix-blend-mode:screen; text-shadow:0 0 6px rgba(97,239,255,.25);
    }
    .hud .k{ color:var(--dim); margin-right:.4rem }
    .hud .v{ color:var(--ink) }
    .hud-tl{ left:12px; top:12px }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="hud hud-tl" id="hudTL"></div>

  <script>
  'use strict';

  // ===== Canvas + World/View (fixed world, scaled view) =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false, desynchronized:true, antialias:true });

  // World coordinates (physics space)
  const WORLD = { w: 1280, h: 720 };
  let W = WORLD.w, H = WORLD.h;

  // View transform (world -> screen)
  const VIEW = { scale: 1, ox: 0, oy: 0, dpr: 1 };

  // Framing: ensure the red detection ring fits in the bottom-left quadrant
  const FRAMING = {
  mode: 'cover',
  pad: 6,          // was 12 — smaller pad => larger scale while still in-frame
  frac: 0.58       // NEW: portion of the screen used for the “quadrant” (0.5 = exact quadrant)
};

  function applyView(){
    ctx.setTransform(
      VIEW.dpr * VIEW.scale, 0,
      0, VIEW.dpr * VIEW.scale,
      VIEW.ox * VIEW.dpr, VIEW.oy * VIEW.dpr
    );
  }
  function fullClear(){
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.restore();
  }

  function setSize(){
    const sw = Math.max(320, Math.floor((window.visualViewport?.width  || window.innerWidth)));
    const sh = Math.max(320, Math.floor((window.visualViewport?.height || window.innerHeight)));
    VIEW.dpr = Math.max(1, window.devicePixelRatio || 1);

    canvas.style.width  = sw + 'px';
    canvas.style.height = sh + 'px';
    canvas.width  = Math.round(sw * VIEW.dpr);
    canvas.height = Math.round(sh * VIEW.dpr);

    // Base scale from mode
    const scaleCover   = Math.max(sw / WORLD.w, sh / WORLD.h);
    const scaleContain = Math.min(sw / WORLD.w, sh / WORLD.h);
    let scale = (FRAMING.mode === 'contain') ? scaleContain : scaleCover;

    // --- Fit the detection circle entirely into the bottom-left quadrant ---
    const pad = FRAMING.pad;
    const frac = FRAMING.frac ?? 0.5;   // default stays 0.5 if you omit it
    const quadW = sw * frac - pad*2;
    const quadH = sh * frac - pad*2;
    const rWorld = tower.r;
    // Max scale so that 2*rWorld fits inside usable quad size
    const fitScale = Math.max(0.001, Math.min(quadW / (2*rWorld), quadH / (2*rWorld)));
    // Final scale: don't exceed fitScale
    VIEW.scale = Math.min(scale, fitScale);

    // Place the head so the circle sits snug inside the bottom-left quadrant with padding
    const rPx = rWorld * VIEW.scale;
    const sx = pad + rPx;            // target screen X for head (left inside quadrant)
    const sy = sh - pad - rPx;       // target screen Y for head (bottom inside quadrant)

    // Solve for view offsets (screen = ox + world*scale)
    VIEW.ox = sx - tower.x * VIEW.scale;
    VIEW.oy = sy - tower.y * VIEW.scale;

    applyView();
  }

  // Visible world rectangle (what the screen shows, in world units)
  function visibleWorldRect(){
    const sw = canvas.width  / VIEW.dpr;
    const sh = canvas.height / VIEW.dpr;
    const vw = sw / VIEW.scale;
    const vh = sh / VIEW.scale;
    const x  = -VIEW.ox / VIEW.scale;
    const y  = -VIEW.oy / VIEW.scale;
    return { x, y, w: vw, h: vh };
  }

  window.addEventListener('resize', setSize, { passive:true });
  window.visualViewport && window.visualViewport.addEventListener('resize', setSize, { passive:true });
  window.addEventListener('orientationchange', setSize, { passive:true });

  // ===== Tower & radar (world-space) =====
  const tower = { x: 170, y: H-160, r: 300, h: 160, sweep: 0, sweepSpeed: 1.18, span: Math.PI/18 };
  const SHOW_TRACK_LINES = false;  // quick toggle for link lines

  // Entities
  const enemies = [];
  const defenders = [];
  const pops = [];
  const DEFENDER_SPAWN_Y_OFFSET = -50;

  // HUD
  let KILLS = 0, lastFpsT = 0, fps = 0, fpsAccum = 0, fpsSamples = 0;
  const hudTL = document.getElementById('hudTL');

  // ===== Helpers =====
  const rand=(a=0,b=1)=>a+Math.random()*(b-a);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const seek=(ax,ay,bx,by)=>{const dx=bx-ax,dy=by-ay;const d=Math.hypot(dx,dy)||1;return {x:dx/d,y:dy/d,d}};
  function radarHead(){ return { x: tower.x, y: tower.y - tower.h - 10 }; }
  function getBeamDir(){ return tower.sweep + Math.PI/2; }
  function getVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

  // ===== Spawning =====
  function spawnEnemy(){
    // distribute across the *visible* width so items aren't off-camera on phones
    const vr = visibleWorldRect();
    const x = rand(vr.x, vr.x + vr.w);
    const y = vr.y - 30 - rand(0, H*0.25); // a bit above visible top
    const base = 22 + rand(0,12);
    return { x,y, vx:0, vy:0, speed: base, maxSpeed: base*1.15, jitter: rand(0,1000), detected:false, locked:false, assigned:false, dead:false };
  }
  const PAD_OFFSETS = [ {dx:-60,dy:38},{dx:-30,dy:38},{dx:0,dy:38},{dx:30,dy:38},{dx:60,dy:38}, {dx:-45,dy:64},{dx:-15,dy:64},{dx:15,dy:64},{dx:45,dy:64} ];
  let padIndex=0;
  function defenderSpawnPoint(){
    const o = PAD_OFFSETS[padIndex++ % PAD_OFFSETS.length];
    return {
      x: tower.x + o.dx + rand(-6, 6),
      y: tower.y + o.dy + DEFENDER_SPAWN_Y_OFFSET + rand(-4, 4)
    };
  }
  function spawnDefender(target){
    const p=defenderSpawnPoint();
    defenders.push({ x:p.x, y:p.y, speed: 190, boost:1, target, dead:false });
  }

  // ===== Simulation params =====
  const SEP_EN = 16, SEP_DEF = 16, SEP_CROSS = 10;
  const SWEEP_RANGE = () => tower.r*2;
  const FORCE_INTERCEPT_DIST = () => Math.max(34, tower.r*0.35);
  const INSTANT_POP_DIST    = () => Math.max(14, tower.r*0.12);

  // ===== Sim loop =====
  let paused=false, last=0;

  function step(dt){
    tower.sweep = (tower.sweep + tower.sweepSpeed*dt) % (Math.PI*2);
    if(enemies.length < 24 && Math.random() < 0.026) enemies.push(spawnEnemy());

    const head = radarHead();
    const beamDir = getBeamDir();

    for(const e of enemies){
      if(e.dead) continue;
      e.jitter += dt*0.6;
      const to = seek(e.x,e.y,tower.x,tower.y);
      const wanderAng = (Math.sin(e.jitter*1.3)+Math.cos(e.jitter*1.17))*0.25;
      let vx = Math.cos(Math.atan2(to.y,to.x)+wanderAng)*0.5;
      let vy = Math.sin(Math.atan2(to.y,to.x)+wanderAng)*0.5;

      for(const o of enemies){
        if(o===e||o.dead) continue;
        const dx=e.x-o.x, dy=e.y-o.y; const d=Math.hypot(dx,dy);
        if(d>0 && d<SEP_EN){ const push=(SEP_EN-d)*0.02; vx += (dx/d)*push; vy += (dy/d)*push; }
      }

      const mag=Math.hypot(vx,vy)||1; vx/=mag; vy/=mag;
      const sp = clamp(e.speed, 10, e.maxSpeed);
      e.vx = vx * sp * dt; e.vy = vy * sp * dt; e.x += e.vx; e.y += e.vy;

      // Detection by beam
      const angTo = Math.atan2(e.y-head.y, e.x-head.x);
      const inBeam = Math.abs(((angTo - beamDir + Math.PI*3)%(Math.PI*2))-Math.PI) < tower.span;
      const distHead = Math.hypot(e.x-head.x, e.y-head.y);
      if(!e.detected && inBeam && distHead <= SWEEP_RANGE()){
        e.detected=true; if(!e.assigned){ e.assigned=true; spawnDefender(e);} }

      if(!e.locked && e.detected && distHead <= tower.r){ e.locked = true; }

      if(e.locked && distHead < FORCE_INTERCEPT_DIST()){
        let best=null, bd=1e9;
        for(const d of defenders){ if(d.dead) continue; const dx=d.x-e.x, dy=d.y-e.y; const dd=dx*dx+dy*dy; if(dd<bd){bd=dd; best=d;} }
        if(!best){ spawnDefender(e); best = defenders[defenders.length-1]; }
        best.target=e; best.boost = Math.max(best.boost||1, 2.2);
        const v = seek(best.x,best.y,e.x,e.y);
        if(v.d < INSTANT_POP_DIST()){ pops.push({x:e.x,y:e.y,a:1}); best.dead=true; e.dead=true; KILLS++; }
      }

      const vr = visibleWorldRect();
      if(e.y > (vr.y + vr.h) + 140) e.dead = true;
    }

    for(const d of defenders){
      if(d.dead || !d.target || d.target.dead){ d.dead=true; continue; }
      d.speed = d.target.speed; d.boost = Math.max(1, d.boost||1);
      const v=seek(d.x,d.y,d.target.x,d.target.y);
      d.x += v.x*d.speed*d.boost*dt; d.y += v.y*d.speed*d.boost*dt;
      if(v.d<11){ pops.push({x:d.target.x,y:d.target.y,a:1}); d.dead=true; if(!d.target.dead){ d.target.dead=true; KILLS++; } }
      d.boost = Math.max(1, d.boost - dt*0.8);
    }

    separatePairs(enemies, SEP_EN);
    separatePairs(defenders, SEP_DEF);
    separateCross(enemies, defenders, SEP_CROSS);

    for(const p of pops){ p.a -= dt*5.5; }

    // cleanup
    for(let i=enemies.length-1;i>=0;i--) if(enemies[i].dead) enemies.splice(i,1);
    for(let i=defenders.length-1;i>=0;i--) if(defenders[i].dead) defenders.splice(i,1);
    for(let i=pops.length-1;i>=0;i--) if(pops[i].a<=0) pops.splice(i,1);
  }

  // ===== Separation helpers =====
  function separatePairs(list, minDist){
    for(let i=0;i<list.length;i++){
      const a=list[i]; if(!a || a.dead) continue;
      for(let j=i+1;j<list.length;j++){
        const b=list[j]; if(!b || b.dead) continue;
        const dx=b.x-a.x, dy=b.y-a.y; const d=Math.hypot(dx,dy);
        if(d>0 && d<minDist){
          const push=(minDist-d)/2; const nx=dx/d, ny=dy/d;
          a.x -= nx*push; a.y -= ny*push; b.x += nx*push; b.y += ny*push;
        }
      }
    }
  }
  function separateCross(A,B,minDist){
    for(const a of A){
      if(a.dead) continue;
      for(const b of B){
        if(b.dead) continue;
        if(b.target===a) continue;
        const dx=b.x-a.x, dy=b.y-a.y; const d=Math.hypot(dx,dy);
        if(d>0 && d<minDist){
          const push=(minDist-d)/2; const nx=dx/d, ny=dy/d;
          a.x -= nx*push; a.y -= ny*push; b.x += nx*push; b.y += ny*push;
        }
      }
    }
  }

  // ===== Drawing =====
  function drawGrid(){
    const head = radarHead();
    const vr = visibleWorldRect();

    // 1) Cartesian grid across visible rect
    ctx.save();
    ctx.lineWidth = 1;
    ctx.strokeStyle = getVar('--grid');
    ctx.globalAlpha = 0.6;
    const s = 32;

    const startX = Math.floor(vr.x / s) * s, endX = vr.x + vr.w;
    for (let x = startX; x <= endX; x += s) {
      ctx.beginPath(); ctx.moveTo(x, vr.y); ctx.lineTo(x, vr.y + vr.h); ctx.stroke();
    }
    const startY = Math.floor(vr.y / s) * s, endY = vr.y + vr.h;
    for (let y = startY; y <= endY; y += s) {
      ctx.beginPath(); ctx.moveTo(vr.x, y); ctx.lineTo(vr.x + vr.w, y); ctx.stroke();
    }

    // 2) Radial fade mask over visible rect
    const innerRadius = Math.max(80, Math.min(W, H) * 0.16);
    const outerRadius = Math.max(W, H) * 0.65;
    const g = ctx.createRadialGradient(head.x, head.y, innerRadius, head.x, head.y, outerRadius);
    g.addColorStop(0.00, 'rgba(255,255,255,1)');
    g.addColorStop(0.55, 'rgba(255,255,255,0.35)');
    g.addColorStop(1.00, 'rgba(255,255,255,0)');

    ctx.globalCompositeOperation = 'destination-in';
    ctx.fillStyle = g;
    ctx.fillRect(vr.x, vr.y, vr.w, vr.h);
    ctx.restore();
  }

  function drawBeamFullBar(){
    const head = radarHead();
    const dir  = getBeamDir();
    const span = tower.span;
    const R    = SWEEP_RANGE();

    const rodAngle = tower.sweep;
    const ux = Math.cos(rodAngle), uy = Math.sin(rodAngle);
    const rodHalf = 30;
    const A = { x: head.x - ux*rodHalf, y: head.y - uy*rodHalf };
    const B = { x: head.x + ux*rodHalf, y: head.y + uy*rodHalf };

    const vL = { x: Math.cos(dir + span), y: Math.sin(dir + span) };
    const vR = { x: Math.cos(dir - span), y: Math.sin(dir - span) };

    function rayCircle(P, v){
      const rx = v.x, ry = v.y;
      const px = P.x - head.x, py = P.y - head.y;
      const dot  = px*rx + py*ry;
      const disc = dot*dot - (px*px + py*py - R*R);
      if (disc < 0) return { x:P.x, y:P.y };
      let t = -dot + Math.sqrt(disc);
      if (t < 0) t = -dot - Math.sqrt(disc);
      return { x: P.x + rx*t, y: P.y + ry*t };
    }

    const D = rayCircle(A, vL);
    const C = rayCircle(B, vR);

    let aL = Math.atan2(D.y - head.y, D.x - head.x);
    let aR = Math.atan2(C.y - head.y, C.x - head.x);
    const TWO_PI = Math.PI * 2;
    let delta = (aL - aR) % TWO_PI; if (delta < 0) delta += TWO_PI;
    const anticlockwise = delta > Math.PI;

    const g = ctx.createRadialGradient(head.x, head.y, 0, head.x, head.y, R);
    g.addColorStop(0.00, getVar('--beam-core'));
    g.addColorStop(0.25, getVar('--beam-fill'));
    g.addColorStop(1.00, 'rgba(0,0,0,0)');

    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.shadowBlur = 18;
    ctx.shadowColor = 'rgba(160, 255, 120, .22)'; // NVG green bloom
    ctx.fillStyle = g;

    ctx.beginPath();
    ctx.moveTo(A.x, A.y);
    ctx.lineTo(B.x, B.y);
    ctx.lineTo(C.x, C.y);
    ctx.arc(head.x, head.y, R, aR, aL, anticlockwise);
    ctx.lineTo(A.x, A.y);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function drawTower(){
    const head=radarHead();
    ctx.save();
    ctx.save();
    ctx.lineWidth=2; ctx.strokeStyle='rgba(255,255,255,.95)'; ctx.shadowBlur=12; ctx.shadowColor='rgba(255,255,255,.35)';
    ctx.translate(head.x, head.y);
    ctx.rotate(tower.sweep);
    ctx.beginPath(); ctx.moveTo(-30,0); ctx.lineTo(30,0); ctx.stroke();
    ctx.restore();

    ctx.strokeStyle='rgba(255,255,255,.65)'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.arc(head.x, head.y, 12, 0, Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(head.x-18, head.y); ctx.lineTo(head.x+18, head.y);
    ctx.moveTo(head.x, head.y-18); ctx.lineTo(head.x, head.y+18); ctx.stroke();
    ctx.restore();
  }

  function drawRangeRing(){
    const head = radarHead();
    ctx.save();
    ctx.setLineDash([6,6]);
    ctx.strokeStyle=getVar('--locked'); ctx.lineWidth=0.5;
    ctx.beginPath(); ctx.arc(head.x,head.y,tower.r,0,Math.PI*2); ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }

  // ===== Symbols =====
  function drawEnemyTriangle(x,y,color){
    ctx.save();
    ctx.translate(x,y);
    ctx.strokeStyle=color;
    ctx.lineWidth=1.4;
    ctx.shadowBlur = 8;
    ctx.shadowColor = color + '55';
    const s=8;
    ctx.beginPath();
    ctx.moveTo(0, s);
    ctx.lineTo(-s, -s);
    ctx.lineTo(s, -s);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
  function drawFriendlyChevron(x,y,color){
    ctx.save();
    ctx.translate(x,y);
    ctx.strokeStyle=color;
    ctx.lineWidth=1.4;
    ctx.shadowBlur = 8;
    ctx.shadowColor = color + '55';
    const s=9;
    ctx.beginPath();
    ctx.moveTo(-s, -s*0.4);
    ctx.lineTo(0, s*0.8);
    ctx.lineTo(s, -s*0.4);
    ctx.stroke();
    ctx.restore();
  }
  function drawLockBracket(x,y,color){
    ctx.save();
    ctx.translate(x,y);
    ctx.shadowBlur = 0;
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-10,-12); ctx.lineTo(-16,-12); ctx.lineTo(-16,-6);
    ctx.moveTo(10,-12);  ctx.lineTo(16,-12);  ctx.lineTo(16,-6);
    ctx.moveTo(-10,12);  ctx.lineTo(-16,12);  ctx.lineTo(-16,6);
    ctx.moveTo(10,12);   ctx.lineTo(16,12);   ctx.lineTo(16,6);
    ctx.stroke();
    ctx.restore();
  }

  function drawDrones(){
    const head = radarHead();

    if (SHOW_TRACK_LINES) {
      for (const e of enemies) {
        if (e.dead || !e.detected) continue;
        const distHead = Math.hypot(e.x - head.x, e.y - head.y);
        const col = (distHead <= tower.r) ? getVar('--locked') : '#ffffff';
        ctx.strokeStyle = col; ctx.lineWidth = 0.8; ctx.globalAlpha = 0.9;
        ctx.beginPath(); ctx.moveTo(head.x, head.y); ctx.lineTo(e.x, e.y); ctx.stroke();
      }
      ctx.globalAlpha = 1;
    }

    for(const e of enemies){
      if(e.dead) continue;
      const triColor = e.locked ? getVar('--locked') : '#ffffff';
      drawEnemyTriangle(e.x, e.y, triColor);

      if(e.detected){
        const distHead=Math.hypot(e.x-head.x, e.y-head.y);
        const bracketColor = (distHead<=tower.r) ? getVar('--locked') : '#ffffff';
        drawLockBracket(e.x, e.y, bracketColor);
      }
    }
    for(const d of defenders){
      if(d.dead) continue;
      drawFriendlyChevron(d.x, d.y, getVar('--defender'));
    }
  }

  function drawPops(){
    for(const p of pops){
      ctx.save();
      ctx.globalAlpha = Math.max(0, p.a);
      ctx.fillStyle = '#ffffff';
      ctx.shadowBlur = 18;
      ctx.shadowColor = 'rgba(255,255,255,.8)';
      ctx.beginPath(); ctx.arc(p.x,p.y,5,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }
  }

  function drawScanlines(){
    const vr = visibleWorldRect();
    ctx.save();
    ctx.globalAlpha = 0.06;
    for(let y=Math.floor(vr.y); y<=vr.y+vr.h; y+=2){
      ctx.fillStyle = '#000';
      ctx.fillRect(vr.x, y, vr.w, 1);
    }
    ctx.restore();
  }

  function drawVignette(){
    const vr = visibleWorldRect();
    const g = ctx.createRadialGradient(
      W*0.5, H*0.5, Math.min(W,H)*0.2,
      W*0.5, H*0.5, Math.max(W,H)*0.7
    );
    g.addColorStop(0, 'rgba(0,0,0,0)');
    g.addColorStop(1, 'rgba(0,0,0,0.5)');
    ctx.save();
    ctx.fillStyle = g;
    ctx.fillRect(vr.x, vr.y, vr.w, vr.h);
    ctx.restore();
  }

  function draw(){
    fullClear();        // clear entire physical canvas
    applyView();        // re-apply view transform after clear

    // Background layers
    drawGrid();
    drawBeamFullBar();

    // Tactical layers
    drawRangeRing();
    drawDrones();
    drawPops();

    // Foreground
    drawTower();

    // Screen treatments
    drawScanlines();
    drawVignette();
  }

  // ===== HUD =====
  let hudTimer = 0;
  function updateHUD(dt){
    hudTimer += dt;
    if(hudTimer < 0.25) return;
    hudTimer = 0;

    const tracks = enemies.reduce((n, e) => n + (e.detected ? 1 : 0), 0);
    const locks  = enemies.reduce((n, e) => n + (e.locked   ? 1 : 0), 0);
    const defendersActive = defenders.length;

    hudTL.innerHTML = `
      <div><span class="k">Tracks</span><span class="v">${tracks}</span></div>
      <div><span class="k">Locks</span><span class="v" style="color:${getVar('--locked')}">${locks}</span></div>
      <div><span class="k">Interceptions</span><span class="v">${KILLS}</span></div>
      <div><span class="k">Defenders</span><span class="v" style="color:${getVar('--defender')}">${defendersActive}</span></div>
    `;
  }

  // ===== Tests =====
  function runTests(){
    const diff = ((getBeamDir() - (tower.sweep + Math.PI/2) + Math.PI*3)%(Math.PI*2))-Math.PI;
    console.assert(Math.abs(diff) < 1e-6, 'Beam not perpendicular to rod');
    try { drawBeamFullBar(); } catch (e) { console.error('Beam draw failed', e); }
  }
  setInterval(runTests, 5000);

  // ===== Loop =====
  function loop(nowMs){
    const now = nowMs || performance.now();
    const dt = Math.min(0.05, (now-last)/1000 || 0.016);
    fpsAccum += 1/dt; fpsSamples++;
    if(!lastFpsT) lastFpsT = now;
    if(now - lastFpsT > 500){ fps = Math.max(1, Math.round(fpsAccum / fpsSamples)); fpsAccum = 0; fpsSamples = 0; lastFpsT = now; }

    last = now;
    if(!paused) step(dt);
    draw();
    updateHUD(dt);
    requestAnimationFrame(loop);
  }

  function init(){
    setSize();
    for(let i=0;i<6;i++) enemies.push(spawnEnemy());
    last = performance.now();
    requestAnimationFrame(loop);
  }
  if(document.readyState==='loading') window.addEventListener('DOMContentLoaded', init);
  else init();

  </script>
</body>
</html>
